/*-------------------------------------------------------------------------+
|                                                                          |
| Copyright 2005-2011 The ConQAT Project                                   |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+-------------------------------------------------------------------------*/
package org.conqat.engine.dotnet.ila.xml;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.conqat.engine.commons.keys.IDependencyListKey;
import org.conqat.engine.commons.node.ListNode;
import org.conqat.engine.commons.node.NodeUtils;
import org.conqat.engine.commons.pattern.PatternList;
import org.conqat.engine.core.core.ConQATException;
import org.conqat.engine.dotnet.ila.EMemberType;
import org.conqat.engine.dotnet.ila.ILDependenciesImporterProcessor;
import org.conqat.engine.dotnet.ila.ILImporterProcessorBase;
import org.conqat.engine.dotnet.ila.Member;
import org.conqat.engine.resource.text.ITextElement;
import org.conqat.lib.commons.collections.ToStringComparator;
import org.conqat.lib.commons.error.NeverThrownRuntimeException;
import org.conqat.lib.commons.string.StringUtils;
import org.conqat.lib.commons.xml.IXMLElementProcessor;

/**
 * Reads members from Intermediate Language Analyzer XML files into a
 * representation that can be used for architecture assessments.
 * <p>
 * The currently implemented approach is very simplistic (Change it as soon as
 * need arises): All classes encountered in the IL-XML are read and appended as
 * children to a single root. Dependencies are stored in a key called
 * {@value IDependencyListKey#DEPENDENCY_LIST_KEY}.
 * 
 * @author $Author: streitel $
 * @version $Revision: 50996 $
 * @ConQAT.Rating RED Hash: C257E2ED9E411643977D6B409D48F676
 */
public class IlaXmlReader extends IlaXmlReaderBase<NeverThrownRuntimeException> {

	/** Pattern to extract (or delete) the inner class prefix of type names. */
	// TODO (FS) if this can be used to extract that prefix, please document
	// what the different capture groups mean. you might also cosider using (?:)
	// to mark groups that contain irrelevant information (these will not be
	// captured)
	public static final Pattern SYNTHETIC_INNER_CLASS_PREFIX = Pattern
			.compile("((/(<>)?c__(DisplayClass|Iterator|AnonStorey)[0-9a-fA-F]+|/(.*>)?d__[0-9a-fA-F]+)(<[^>]*>)?)+");

	/** Cache of type nodes referenced by their node ID. */
	private final HashMap<String, ListNode> typeCache = new HashMap<String, ListNode>();

	/** Flag that determines whether to ignore types generated by the compiler. */
	private final boolean ignoreSynthetic;

	/**
	 * Flag that determines whether method bodies are included while reading the
	 * XML. Including method bodies impacts the memory footprint.
	 */
	private final boolean includeMethodBody;

	/**
	 * If not null, types whose base class matches one of these patters are
	 * ignored.
	 */
	private final PatternList ignoreBaseTypePatterns;

	/**
	 * Constructor.
	 * 
	 * @param element
	 *            XML that gets parsed.
	 * @param root
	 *            Root under which the nodes representing types found during
	 *            parse are attached
	 * @param ignorePatterns
	 *            List of patterns for members that are ignored during import.
	 * @param includePatterns
	 *            If not null, only members matching one of these patterns are
	 *            included.
	 * @param ignoreBaseTypePatterns
	 *            If not null, only types whose base types are not matched are
	 *            processed.
	 * @param includeMethodBody
	 *            Flag that determines whether the method body gets read from
	 *            XML. This impacts the memory footprint.
	 */
	public IlaXmlReader(ITextElement element, ListNode root,
			PatternList ignorePatterns, PatternList includePatterns,
			PatternList ignoreBaseTypePatterns, boolean ignoreSynthetic,
			boolean includeMethodBody, Set<String> includedDependencies,
			Set<String> excludedDependencies) throws ConQATException {
		super(element, root, ignorePatterns, includePatterns,
				includedDependencies, excludedDependencies);
		this.ignoreSynthetic = ignoreSynthetic;
		this.ignoreBaseTypePatterns = ignoreBaseTypePatterns;
		this.includeMethodBody = includeMethodBody;
	}

	/**
	 * Constructor that is used from test cases.
	 * 
	 * @param element
	 *            XML that gets parsed.
	 * @param root
	 *            Root under which the nodes representing types found during
	 *            parse are attached.
	 */
	/* package */IlaXmlReader(ITextElement element, ListNode root,
			Set<String> includedDependencies, Set<String> excludedDependencies)
			throws ConQATException {
		this(element, root, new PatternList(), null, null, true, false,
				includedDependencies, excludedDependencies);
	}

	/** {@inheritDoc} */
	@Override
	protected void doParse() {
		String assemblyName = getStringAttribute(EIlaXmlAttribute.Name);
		processChildElements(new XmlTypeElementReader(assemblyName));
	}

	/** Retrieve the number of IL statements from the current element */
	private int parseNumerOfIlStmts() {
		String numberIlStatementsString = getStringAttribute(EIlaXmlAttribute.NumILStmts);

		if (StringUtils.isEmpty(numberIlStatementsString)) {
			return 0;
		}

		return Integer.valueOf(numberIlStatementsString);
	}

	/** Processor for IlaXML nodes containing type information. */
	private abstract class IlaXMLElementProcessor implements
			IXMLElementProcessor<EIlaXmlElement, NeverThrownRuntimeException> {

		/**
		 * Returns the type name with IL-generated classes stripped from the
		 * type name.
		 */
		public String getTypeName() {
			String typeName = getStringAttribute(EIlaXmlAttribute.Type);
			return removeSyntheticClasses(typeName);
		}

	}

	/**
	 * Removes synthetic inner classes produced e.g. by yield statements.
	 * 
	 * <pre>
	 * Example:
	 * 
	 * namespace Namespace
	 * {
	 *   class Class : Ifc
	 *   {
	 *     IEnumeration&lt;int&gt; getItem()
	 *     {
	 *       yield return 0;
	 *     }
	 *     IEnumeration&lt;int&gt; Ifc.getItem2()
	 *     {
	 *       yield return 0;
	 *     }
	 *   }
	 * 	
	 *   interface Ifc
	 *   {
	 *     IEnumeration&lt;int&gt; getItem2()
	 *   }
	 * }
	 * 			
	 * Becomes for getItem:
	 * 
	 * Namespace.Class/d__1
	 * for getItem2:
	 * Namespace.Class/getItem2>d__2
	 * 
	 * Besides, closures are compiled to e.g.
	 * Namespace.Class/c__DisplayClass2
	 * while other yield returns are compiled to e.g.
	 * Namespace.Class/c__Iterator1
	 * </pre>
	 */
	private static String removeSyntheticClasses(String typeName) {
		return SYNTHETIC_INNER_CLASS_PREFIX.matcher(typeName).replaceAll(
				StringUtils.EMPTY_STRING);
	}

	/** Processor for &lt;TypeElement&gt; nodes. */
	private class XmlTypeElementReader extends IlaXMLElementProcessor {

		/** Keeps track of the assembly we are currently processing */
		private final String assemblyName;

		/** Constructor */
		public XmlTypeElementReader(String assemblyName) {
			this.assemblyName = assemblyName;
		}

		/** {@inheritDoc} */
		@Override
		public void process() {
			if (skipType()) {
				return;
			}

			String typeName = getTypeName();
			ListNode currentElementNode = typeCache.get(typeName);

			// Since we inline methods of synthetic inner classes,
			// getTypeName() will return the same name more than once
			// in these cases. The information in the following block is
			// not of interest for these classes, so we just store them
			// once. Since the ILA XML always contains the outer class
			// first, we discard all future encounters of the same type name.
			if (currentElementNode == null) {
				currentElementNode = new ListNode(typeName);
				typeCache.put(typeName, currentElementNode);
				root.addChild(currentElementNode);

				currentElementNode.setValue(
						ILImporterProcessorBase.ASSEMBLY_NAME, assemblyName);

				parseDeclType(currentElementNode);
				parseRawName(currentElementNode);
			}

			int ilStatementCount = parseNumerOfIlStmts()
					+ NodeUtils.getValue(currentElementNode,
							ILDependenciesImporterProcessor.IL_STATEMENT_COUNT,
							Integer.class, 0);

			currentElementNode.setValue(
					ILDependenciesImporterProcessor.IL_STATEMENT_COUNT,
					ilStatementCount);

			parseDependencies(currentElementNode, typeName);
			parseMembers(currentElementNode,
					getBooleanAttribute(EIlaXmlAttribute.Synthetic),
					getInnerClassName(),
					getIntAttribute(EIlaXmlAttribute.Token));
		}

		/** Returns the inner class name, if any, or null. */
		private String getInnerClassName() {
			String typeName = getStringAttribute(EIlaXmlAttribute.Type);
			Matcher matcher = SYNTHETIC_INNER_CLASS_PREFIX.matcher(typeName);
			if (matcher.find()) {
				// TODO (FS) I would have expected that a group of the pattern
				// contains the matched name and that I as a user of that
				// pattern don't have to worry about stripping some prefixes
				return StringUtils.stripPrefix(matcher.group(), "/");
			}
			return null;
		}

		/** Read raw name from XML into node. */
		// TODO (FS) only used once and very short. inline?
		private void parseRawName(ListNode currentElementNode) {
			parseAndStoreAttribute(EIlaXmlAttribute.RawName,
					ILDependenciesImporterProcessor.RAW_NAME,
					currentElementNode);
		}

		/** Read declaration type from XML into node. */
		// TODO (FS) only used once and very short. inline?
		private void parseDeclType(ListNode currentElementNode) {
			parseAndStoreAttribute(EIlaXmlAttribute.DeclType,
					ILDependenciesImporterProcessor.DECLTYPE,
					currentElementNode);
		}

		/** Parse attribute value from XML and store in node. */
		private void parseAndStoreAttribute(EIlaXmlAttribute attributeName,
				String targetKey, ListNode node) {
			String value = getStringAttribute(attributeName);
			node.setValue(targetKey, value);
		}

		/** Read dependencies from XML into node. */
		// TODO (FS) please use the more concrete return type Set
		private Collection<String> parseDependencies(
				ListNode currentElementNode, String typeName) {
			Collection<String> dependencies = new HashSet<String>();

			processDecendantElements(new DependsReader(dependencies, typeName,
					EIlaXmlElement.Extends));
			processDecendantElements(new DependsReader(dependencies, typeName,
					EIlaXmlElement.Implements));
			currentElementNode.setValue(IDependencyListKey.SUPER_TYPE_LIST_KEY,
					new HashSet<String>(dependencies));

			processDecendantElements(new DependsReader(dependencies, typeName,
					EIlaXmlElement.Depends));
			currentElementNode.setValue(IDependencyListKey.DEPENDENCY_LIST_KEY,
					dependencies);

			return dependencies;
		}

		/**
		 * Parse members from XML into node
		 * 
		 * @param isSynthetic
		 *            Flag that determines whether member is synthesized by the
		 *            compiler (and thus does not appear in the source code)
		 */
		private void parseMembers(ListNode currentElementNode,
				boolean isSynthetic, String innerClassName, int parentToken) {
			List<Member> members = NodeUtils.getOrCreateTypedList(
					currentElementNode,
					ILDependenciesImporterProcessor.MEMBERS, Member.class);
			processDecendantElements(new MemberReader(members, isSynthetic,
					innerClassName, parentToken));
			Collections.sort(members, ToStringComparator.INSTANCE);
		}

		/** Determines whether a type should be skipped. */
		private boolean skipType() {
			boolean isSynthetic = getBooleanAttribute(EIlaXmlAttribute.Synthetic);
			if (isSynthetic && ignoreSynthetic) {
				return true;
			}

			if (ignoreBaseTypePatterns == null) {
				return false;
			}

			// TODO (FS) comment is redundant. remove?
			// determine base type
			BaseTypeReader reader = new BaseTypeReader();
			processChildElements(reader);
			String baseType = reader.getBaseType();

			// TODO (FS) comment is redundant. remove?
			// match base type against ignore list
			boolean ignore = ignoreBaseTypePatterns.matchesAny(baseType);
			if (ignore) {
				String typeName = getTypeName();
				// TODO (FS) please use a logger
				System.err.println("Ingoring " + typeName + ": Base type: "
						+ baseType);
			}
			return ignore;
		}

		/** {@inheritDoc} */
		@Override
		public EIlaXmlElement getTargetElement() {
			return EIlaXmlElement.TypeElement;
		}

	}

	/** Determines the base type of a type element */
	private class BaseTypeReader extends IlaXMLElementProcessor {

		/** Field to store base type. */
		private String baseType;

		/** {@inheritDoc} */
		@Override
		public EIlaXmlElement getTargetElement() {
			return EIlaXmlElement.Extends;
		}

		/** {@inheritDoc} */
		@Override
		public void process() throws NeverThrownRuntimeException {
			baseType = getTypeName();
		}

		/** Returns base type. */
		public String getBaseType() {
			return baseType;
		}

	}

	/**
	 * Processor that processes dependencies. Target element is passed via the
	 * constructor, since it needs to operate on different target elements.
	 */
	private class DependsReader extends IlaXMLElementProcessor {

		/**
		 * List of dependencies of the type with name {@link #typeName} that are
		 * listed for the given {@link #targetElement}.
		 */
		private final Collection<String> dependencies;

		/** Target element this processor works on. */
		private final EIlaXmlElement targetElement;

		/** Name of type we are currently working on. */
		private final String typeName;

		/** Constructor. */
		public DependsReader(Collection<String> dependencies, String typeName,
				EIlaXmlElement targetElement) {
			this.dependencies = dependencies;
			this.targetElement = targetElement;
			this.typeName = typeName;
		}

		/** {@inheritDoc} */
		@Override
		public EIlaXmlElement getTargetElement() {
			return targetElement;
		}

		/** {@inheritDoc} */
		@Override
		public void process() {
			String target = getTypeName();
			boolean included = processDependency(typeName, target);
			if (included) {
				dependencies.add(target);
			}
		}
	}

	/** Processor for <code>&lt;Member&gt;</code> nodes. */
	private class MemberReader implements
			IXMLElementProcessor<EIlaXmlElement, NeverThrownRuntimeException> {

		/** Reference to list in which members are stored. */
		private final List<Member> members;

		/** Flag that determines whether members are synthetic */
		private final boolean isSynthetic;

		/**
		 * If the member is part of an inner class, this field contains its
		 * name.
		 */
		private final String innerClassName;

		/** The metadata token of the member's parent type. */
		private final int parentMetadataToken;

		/**
		 * Constructor.
		 */
		protected MemberReader(List<Member> members, boolean isSynthetic,
				String innerClassName, int parentMetadataToken) {
			this.members = members;
			this.isSynthetic = isSynthetic;
			this.innerClassName = innerClassName;
			this.parentMetadataToken = parentMetadataToken;
		}

		/** {@inheritDoc} */
		@Override
		public EIlaXmlElement getTargetElement() {
			return EIlaXmlElement.Member;
		}

		/** {@inheritDoc} */
		@Override
		public void process() {
			String name = getStringAttribute(EIlaXmlAttribute.Name);
			String rawName = getStringAttribute(EIlaXmlAttribute.RawName);
			String shortName = getStringAttribute(EIlaXmlAttribute.ShortName);
			String returnType = getStringAttribute(EIlaXmlAttribute.ReturnType);
			EMemberType type = EMemberType
					.valueOf(getStringAttribute(EIlaXmlAttribute.MemberType));
			String visibility = getStringAttribute(EIlaXmlAttribute.Visibility);
			boolean isAbstract = getBooleanAttribute(EIlaXmlAttribute.IsAbstract);
			int token = getIntAttribute(EIlaXmlAttribute.Token);
			String ilStatementSequence = null;
			if (includeMethodBody) {
				ilStatementSequence = getStringAttribute(EIlaXmlAttribute.BodyZip);
			}
			ArrayList<String> parameterTypes = new ArrayList<>();
			processChildElements(new ParametersReader(parameterTypes));
			String genericParameters = getStringAttribute(EIlaXmlAttribute.GenericParameters);

			Member member = new Member(name, rawName, shortName, type,
					visibility, isAbstract, token, parseNumerOfIlStmts(),
					ilStatementSequence, isSynthetic, returnType,
					parameterTypes, genericParameters, innerClassName,
					parentMetadataToken);
			members.add(member);
		}
	}

	/** Processor for reading parameter types into a list. */
	private class ParametersReader implements
			IXMLElementProcessor<EIlaXmlElement, NeverThrownRuntimeException> {
		/** The list of parameter types. */
		private final List<String> parameterTypes;

		/** Constructor. */
		public ParametersReader(List<String> parameterTypes) {
			this.parameterTypes = parameterTypes;
		}

		/** {@inheritDoc} */
		@Override
		public EIlaXmlElement getTargetElement() {
			return EIlaXmlElement.Parameter;
		}

		/** {@inheritDoc} */
		@Override
		public void process() throws NeverThrownRuntimeException {
			parameterTypes.add(getStringAttribute(EIlaXmlAttribute.Type));
		}
	}
}