/*-------------------------------------------------------------------------+
|                                                                          |
| Copyright 2005-2011 The ConQAT Project                                   |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+-------------------------------------------------------------------------*/
package org.conqat.engine.dotnet.gendarme;

import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.conqat.engine.commons.findings.location.ElementLocation;
import org.conqat.engine.core.core.AConQATKey;
import org.conqat.engine.core.core.AConQATProcessor;
import org.conqat.engine.core.core.ConQATException;
import org.conqat.engine.resource.base.ReportReaderBase;
import org.conqat.engine.resource.text.ITextElement;
import org.conqat.engine.resource.util.TextElementXMLReader;
import org.conqat.lib.commons.assertion.CCSMAssert;
import org.conqat.lib.commons.string.StringUtils;
import org.conqat.lib.commons.xml.IXMLElementProcessor;

/**
 * {@ConQAT.Doc}
 * <p>
 * This class uses assertions to document our assumptions about the Gendarme
 * report format where possible via method {@link #assertNotEmpty(String)}. *
 * 
 * @author $Author: hummelb $
 * @version $Rev: 46815 $
 * @ConQAT.Rating GREEN Hash: 07D4D13DD192B8FA96EC7AD4351F3515
 */
@AConQATProcessor(description = "This processor leads XML reports generated by Gendarme "
		+ "(http://www.mono-project.com/Gendarme). " + ReportReaderBase.DOC)
public class GendarmeReportReader extends ReportReaderBase {

	/**
	 * For some mysterious reason, Gendarme uses this symbol to prefix the line
	 * number in the report.
	 */
	private static final char ALMOST_EQUAL_TO = '\u2248';

	/** {@ConQAT.Doc} */
	@AConQATKey(description = "Key for findings", type = "org.conqat.engine.commons.findings.FindingsList")
	public static final String GENDARME = "Gendarme";

	/**
	 * Pattern used to parse {@link EGendarmeAttribute#Source} attribute. Used
	 * to split the the string that describes the source into the part before
	 * and the part inside parentheses. The part before is the filename, the
	 * part inside the parentheses describes the location in the file.
	 */
	private static final Pattern SOURCE_PATTERN = Pattern
			.compile("(.*)\\((.*)\\)");

	/**
	 * Pattern used to parse a single line location (for some mysterious reason,
	 * Gendarme uses \u2284 to prefix the line number).
	 */
	private static final Pattern SINGLE_LINE_PATTERN = Pattern
			.compile(ALMOST_EQUAL_TO + "(\\d+)");

	/**
	 * Pattern used to parse multi line locations. This currently works for two
	 * locations only. However, I did not see any locations with more than two
	 * locations and did not want to overengineer this.
	 */
	private static final Pattern MULTI_LINE_PATTERN = Pattern
			.compile("(\\d+),(\\d+)");

	/**
	 * This maps from rule short names to descriptions. This is populated while
	 * reading the file.
	 */
	private final HashMap<String, String> rules = new HashMap<String, String>();

	/**
	 * Loads a single Gendarme report.
	 */
	@Override
	protected void loadReport(ITextElement report) throws ConQATException {
		new ReportReader(report).read();
	}

	/** {@inheritDoc} */
	@Override
	protected String obtainRuleDescription(String ruleId) {
		return rules.get(ruleId);
	}

	/**
	 * This method is used to document our assumptions about the Gendarme report
	 * format.
	 */
	private static void assertNotEmpty(String string) {
		CCSMAssert
				.isFalse(StringUtils.isEmpty(string),
						"Assumption about Gendarme report format violated. String is empty!");
	}

	/**
	 * Main reader class for Gendarme report.
	 */
	private class ReportReader
			extends
			TextElementXMLReader<EGendarmeElement, EGendarmeAttribute, ConQATException> {

		/** Constructor. */
		private ReportReader(ITextElement report) throws ConQATException {
			super(report, EGendarmeAttribute.class);
		}

		/** Read file. */
		public void read() throws ConQATException {
			parseAndWrapExceptions();
			processDecendantElements(new ResultsProcessor());
		}

		/** Processor for {@link EGendarmeElement#results} */
		private class ResultsProcessor implements
				IXMLElementProcessor<EGendarmeElement, ConQATException> {

			/** {@inheritDoc} */
			@Override
			public EGendarmeElement getTargetElement() {
				return EGendarmeElement.results;
			}

			/** {@inheritDoc} */
			@Override
			public void process() throws ConQATException {
				processChildElements(new RuleProcessor());
			}
		}

		/**
		 * Processor for {@link EGendarmeElement#rule} (within a
		 * {@link EGendarmeElement#results} element).
		 */
		private class RuleProcessor implements
				IXMLElementProcessor<EGendarmeElement, ConQATException> {

			/** {@inheritDoc} */
			@Override
			public EGendarmeElement getTargetElement() {
				return EGendarmeElement.rule;
			}

			/** {@inheritDoc} */
			@Override
			public void process() throws ConQATException {
				String ruleName = getStringAttribute(EGendarmeAttribute.Name);
				String description = getChildText(EGendarmeElement.problem);
				assertNotEmpty(ruleName);
				assertNotEmpty(description);

				rules.put(ruleName, description);
				processChildElements(new TargetProcessor(ruleName));
			}

		}

		/** Processor for {@link EGendarmeElement#target}. */
		private class TargetProcessor implements
				IXMLElementProcessor<EGendarmeElement, ConQATException> {

			/** The rule name */
			private final String ruleName;

			/** Constructor. */
			public TargetProcessor(String ruleName) {
				this.ruleName = ruleName;
			}

			/** {@inheritDoc} */
			@Override
			public EGendarmeElement getTargetElement() {
				return EGendarmeElement.target;
			}

			/** {@inheritDoc} */
			@Override
			public void process() throws ConQATException {
				String targetElementName = getStringAttribute(EGendarmeAttribute.Name);
				assertNotEmpty(targetElementName);
				processChildElements(new DefectProcessor(ruleName,
						targetElementName));
			}

		}

		/** Processor for {@link EGendarmeElement#defect}. */
		private class DefectProcessor implements
				IXMLElementProcessor<EGendarmeElement, ConQATException> {

			/** The rule name */
			private final String ruleName;

			/** The target element name. */
			private final String targetElementName;

			/** Constructor. */
			public DefectProcessor(String ruleName, String targetElementName) {
				this.ruleName = ruleName;
				this.targetElementName = targetElementName;
			}

			/** {@inheritDoc} */
			@Override
			public EGendarmeElement getTargetElement() {
				return EGendarmeElement.defect;
			}

			/** {@inheritDoc} */
			@Override
			public void process() throws ConQATException {

				String locationString = getStringAttribute(EGendarmeAttribute.Location);
				assertNotEmpty(locationString);
				String qName = targetElementName + "/" + locationString;

				String source = obtainSource(qName);

				if (source == null) {
					// this has been logged before
					return;
				}

				String message = getText();
				if (StringUtils.isEmpty(message)) {
					message = "<no description>";
				}

				parseSourceAndCreateFindings(source, qName, message);
			}

			/** Obtain source from attribute {@link EGendarmeAttribute#Source}. */
			private String obtainSource(String qName) {
				String source = getStringAttribute(EGendarmeAttribute.Source);
				if (StringUtils.isEmpty(source)) {
					getLogger().warn(
							"Source not specified for finding at location "
									+ qName);
					return null;
				}
				if (source.startsWith("debugging symbols unavailable")) {
					getLogger().warn(
							"Debug information is missing for " + qName
									+ ". Cannot determine source file!");
					return null;
				}
				return source;
			}

			/** Parse source string and create findings. */
			private void parseSourceAndCreateFindings(String source,
					String qName, String message) throws ConQATException {
				Matcher sourceMatcher = SOURCE_PATTERN.matcher(source);
				if (!sourceMatcher.matches()) {
					getLogger().warn(
							"Unknown source format for finding at " + qName);
					return;
				}

				String location = sourceMatcher.group(1);
				String locationDescriptor = sourceMatcher.group(2);

				Matcher singleLineMatcher = SINGLE_LINE_PATTERN
						.matcher(locationDescriptor);

				if (singleLineMatcher.matches()) {
					createLineFinding(message, singleLineMatcher.group(1),
							qName, location);
					return;
				}

				Matcher multiLineMatcher = MULTI_LINE_PATTERN
						.matcher(locationDescriptor);

				if (multiLineMatcher.matches()) {
					// we only keep the first location in this case
					createLineFinding(message, multiLineMatcher.group(1),
							qName, location);
					return;
				}

				if ((ALMOST_EQUAL_TO + "unavailable")
						.equals(locationDescriptor)) {
					getLogger().info(
							"Line number unavailable for finding at " + qName);
				} else {
					getLogger().info(
							"Unknown line location format for finding at "
									+ qName);
				}

				createFindingForFileLocation(ruleName, message, location);
			}

			/**
			 * Creates a finding for a code line. This checks if the line
			 * information is a valid integer. If not a plain
			 * {@link ElementLocation} is used for the finding.
			 */
			private void createLineFinding(String message, String lineString,
					String qName, String location) throws ConQATException {
				try {
					int lineNumber = Integer.parseInt(lineString);
					GendarmeReportReader.this.createLineFinding(ruleName,
							message, location, lineNumber);
				} catch (NumberFormatException ex) {
					getLogger().warn(
							"Invalid source line information for finding at "
									+ qName);
					createFindingForFileLocation(ruleName, message, location);
				}
			}
		}

	}

}