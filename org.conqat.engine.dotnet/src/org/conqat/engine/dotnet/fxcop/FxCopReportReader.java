/*-------------------------------------------------------------------------+
|                                                                          |
| Copyright 2005-2011 The ConQAT Project                                   |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+-------------------------------------------------------------------------*/
package org.conqat.engine.dotnet.fxcop;

import java.io.File;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

import org.conqat.engine.commons.findings.location.ElementLocation;
import org.conqat.engine.core.core.AConQATKey;
import org.conqat.engine.core.core.AConQATProcessor;
import org.conqat.engine.core.core.ConQATException;
import org.conqat.engine.core.logging.ELogLevel;
import org.conqat.engine.dotnet.types.CodeEntityFactory;
import org.conqat.engine.resource.base.ReportReaderBase;
import org.conqat.engine.resource.text.ITextElement;
import org.conqat.engine.resource.text.ITextResource;
import org.conqat.engine.resource.util.ElementUniformPathComparator;
import org.conqat.engine.resource.util.ResourceTraversalUtils;
import org.conqat.engine.resource.util.TextElementXMLReader;
import org.conqat.engine.resource.util.UniformPathUtils;
import org.conqat.engine.sourcecode.resource.ITokenElement;
import org.conqat.lib.commons.assertion.CCSMAssert;
import org.conqat.lib.commons.collections.CollectionUtils;
import org.conqat.lib.commons.collections.UnmodifiableList;
import org.conqat.lib.commons.string.StringUtils;
import org.conqat.lib.commons.xml.IXMLElementProcessor;
import org.conqat.lib.scanner.IToken;

/**
 * {@ConQAT.Doc}
 * 
 * @author $Author: streitel $
 * @version $Rev: 50476 $
 * @ConQAT.Rating RED Hash: 0BA3FB5EE8C91097C9756AF3440BBB62
 */
@AConQATProcessor(description = "This processor reads XML reports generated by FxCop. "
		+ "For each issue found by FxCop that has a path associated, a finding is generated. "
		+ "The finding is filled with the name and description of the rule that is violated by "
		+ "the issue, the file and if available the line in which the issue occured. "
		+ ReportReaderBase.DOC)
public class FxCopReportReader extends ReportReaderBase {

	/** {@ConQAT.Doc} */
	@AConQATKey(description = "Key for findings", type = "org.conqat.engine.commons.findings.FindingsList")
	public static final String FXCOP = "FxCop";

	/**
	 * This maps from rule short names to descriptions. This is populated while
	 * reading the file.
	 */
	private final HashMap<String, String> ruleDescriptions = new HashMap<String, String>();

	/**
	 * This maps from full qualified type names to the element that contains the
	 * type.
	 */
	private final Map<String, ITokenElement> typesToElements = new HashMap<String, ITokenElement>();

	/** {@inheritDoc} */
	@Override
	protected String obtainRuleDescription(String ruleId) {
		return ruleDescriptions.get(ruleId);
	}

	/** {@inheritDoc} */
	@Override
	protected void setUp(ITextResource input) throws ConQATException {
		List<ITokenElement> elements = ResourceTraversalUtils.listElements(
				input, ITokenElement.class);
		// it is important to sort this to ensure a stable mapping. For partial
		// classes we associate only one file with the type. This should always
		// be the same.
		for (ITokenElement element : CollectionUtils.sort(elements,
				new ElementUniformPathComparator())) {
			UnmodifiableList<IToken> tokens = element.getTokens(getLogger());
			List<String> typeFqNames = CodeEntityFactory
					.codeEntitiesFor(tokens).collectTypeNames();
			for (String typeName : typeFqNames) {
				typesToElements.put(typeName, element);
			}
		}
	}

	/** {@inheritDoc} */
	@Override
	protected void loadReport(ITextElement report) throws ConQATException {
		new FxCopFileReader(report).parse();
	}

	/** The reader for FxCop reports. */
	private class FxCopFileReader
			extends
			TextElementXMLReader<EFxCopElement, EFxCopAttribute, ConQATException> {

		/** Constructor */
		public FxCopFileReader(ITextElement report) throws ConQATException {
			super(report, EFxCopAttribute.class);
		}

		/** Start parsing. */
		public void parse() throws ConQATException {
			parseAndWrapExceptions();
			readExceptions();
			extractRules();
			createFindings();
		}

		/**
		 * Extract rule information from the XML file that is required for
		 * creating the findings.
		 */
		private void extractRules() throws ConQATException {
			processDecendantElements(new RuleProcessor());
		}

		/** Create the findings. */
		private void createFindings() throws ConQATException {
			processDecendantElements(new NamespaceProcessor());
		}

		/** Reads analysis exceptions that are stored in the XML and logs them. */
		private void readExceptions() throws ConQATException {
			processDecendantElements(new AnalysisExcpetionProcessor());
		}

		/** XML processor for rule elements. */
		private class RuleProcessor implements
				IXMLElementProcessor<EFxCopElement, ConQATException> {

			/** {@inheritDoc} */
			@Override
			public EFxCopElement getTargetElement() {
				return EFxCopElement.Rule;
			}

			/** {@inheritDoc} */
			@Override
			public void process() {
				String typeName = getStringAttribute(EFxCopAttribute.TypeName);
				String description = getChildText(EFxCopElement.Description);

				CCSMAssert.isFalse(StringUtils.isEmpty(typeName),
						"The type name of the rule should not be empty");
				CCSMAssert.isFalse(StringUtils.isEmpty(description),
						"The description of the rule should not be empty");

				ruleDescriptions.put(typeName, description);
			}

		}

		/** XML processor for namespace elements. */
		private class NamespaceProcessor implements
				IXMLElementProcessor<EFxCopElement, ConQATException> {

			/** {@inheritDoc} */
			@Override
			public EFxCopElement getTargetElement() {
				return EFxCopElement.Namespace;
			}

			/** {@inheritDoc} */
			@Override
			public void process() throws ConQATException {
				String namespaceName = getStringAttribute(EFxCopAttribute.Name);
				processDecendantElements(new TypeProcessor(namespaceName));
			}

		}

		/** XML processor for type elements. */
		private class TypeProcessor implements
				IXMLElementProcessor<EFxCopElement, ConQATException> {

			/**
			 * The name of the namespace this type belongs to, empty string if
			 * in the global namespace.
			 */
			private final String namespaceName;

			/** Constructor. */
			public TypeProcessor(String namespaceName) {
				this.namespaceName = namespaceName;
			}

			/** {@inheritDoc} */
			@Override
			public EFxCopElement getTargetElement() {
				return EFxCopElement.Type;
			}

			/** {@inheritDoc} */
			@Override
			public void process() throws ConQATException {
				String typeName = getStringAttribute(EFxCopAttribute.Name);
				CCSMAssert.isFalse(StringUtils.isEmpty(typeName),
						"Type name not set");

				if (!StringUtils.isEmpty(namespaceName)) {
					typeName = namespaceName + "." + typeName;
				}
				processDecendantElements(new MessageProcessor(typeName));
			}

		}

		/** XML processor for message elements. */
		public class MessageProcessor implements
				IXMLElementProcessor<EFxCopElement, ConQATException> {

			/** The full qualified name of the type the message belongs to. */
			private final String fqTypeName;

			/** Constructor. */
			public MessageProcessor(String fqTypeNme) {
				this.fqTypeName = fqTypeNme;
			}

			/** {@inheritDoc} */
			@Override
			public EFxCopElement getTargetElement() {
				return EFxCopElement.Message;
			}

			/** {@inheritDoc} */
			@Override
			public void process() throws ConQATException {
				String ruleId = getStringAttribute(EFxCopAttribute.TypeName)
						+ " (" + getStringAttribute(EFxCopAttribute.CheckId)
						+ ")";

				// TODO (FS) assertion references "type id" but variable is
				// named "rule id". is this a typo?
				CCSMAssert.isFalse(StringUtils.isEmpty(ruleId),
						"The type id of the message should not be empty");

				processChildElements(new IssueProcessor(ruleId, fqTypeName));
			}
		}

		/** XML processor for issue elements within message elements. */
		public class IssueProcessor implements
				IXMLElementProcessor<EFxCopElement, ConQATException> {

			/** The finding rule id. */
			private final String ruleId;

			/** The full qualified name of the type the issue belongs to. */
			private final String fqTypeName;

			/** Constructor. */
			public IssueProcessor(String ruleId, String fqTypeName) {
				this.ruleId = ruleId;
				this.fqTypeName = fqTypeName;
			}

			/** {@inheritDoc} */
			@Override
			public EFxCopElement getTargetElement() {
				return EFxCopElement.Issue;
			}

			/** {@inheritDoc} */
			@Override
			public void process() throws ConQATException {

				String message = getText();

				if (StringUtils.isEmpty(message)) {
					message = "<missing message>";
				}

				String path = getStringAttribute(EFxCopAttribute.Path);
				String file = getStringAttribute(EFxCopAttribute.File);

				// FxCop reports store the source file only for findings within
				// methods. Findings for types or fields do not carry source
				// information. To use them, we determine the element that
				// stores the affected type and attach the finding there. If a
				// type is spread over multiple files, the finding is attached
				// to only one of them.
				if (StringUtils.isEmpty(path) || StringUtils.isEmpty(file)) {
					createTypeBasedFinding(ruleId, message);
				} else {
					createFileBasedFinding(ruleId, message, path, file);
				}
			}

			/** Create finding based on the type name. */
			private void createTypeBasedFinding(String ruleId, String message)
					throws ConQATException {
				String type = fqTypeName;

				// trim inner class names
				int cutAfter = type.indexOf("+");
				if (cutAfter != -1) {
					type = type.substring(0, cutAfter);
				}

				ITokenElement targetElement = typesToElements.get(type);

				if (targetElement == null) {
					handleError("Report " + element.getLocation()
							+ " refers to unknown type " + fqTypeName);
					return;
				}

				createFinding(ruleId, message,
						new ElementLocation(targetElement.getLocation(),
								targetElement.getUniformPath()), targetElement);
			}

			/**
			 * Creates a finding based on file information. We use this if
			 * available as it also supplies the line number.
			 */
			private void createFileBasedFinding(String ruleId, String message,
					String path, String file) throws ConQATException {
				String fileLocation = new File(path, file).getPath();

				String lineAsString = getStringAttribute(EFxCopAttribute.Line);
				if (StringUtils.isEmpty(lineAsString)) {
					createFindingForFileLocation(ruleId, message, fileLocation);
					return;
				}

				try {
					int line = Integer.valueOf(lineAsString);
					createLineFinding(ruleId, message, fileLocation, line);
				} catch (NumberFormatException e) {
					getLogger().warn(
							"Error parsing line for finding at " + lineAsString
									+ " in report " + element.getLocation());
					createFindingForFileLocation(ruleId, message, fileLocation);
				}
			}
		}

		/** XML processor for analysis exception elements. */
		private class AnalysisExcpetionProcessor implements
				IXMLElementProcessor<EFxCopElement, ConQATException> {

			/** {@inheritDoc} */
			@Override
			public EFxCopElement getTargetElement() {
				return EFxCopElement.Exception;
			}

			/** {@inheritDoc} */
			@Override
			public void process() {
				String message = getChildText(EFxCopElement.ExceptionMessage);
				String innerMessage = getChildText(EFxCopElement.InnerExceptionMessage);
				if (!StringUtils.isEmpty(innerMessage)) {
					message += StringUtils.CR + innerMessage;
				}

				ELogLevel level = ELogLevel.ERROR;
				if (getBooleanAttribute(EFxCopAttribute.TreatAsWarning)) {
					level = ELogLevel.WARN;
				}

				getLogger().log(
						level,
						"FxCop threw an exception while writing "
								+ UniformPathUtils
										.getElementName(getLocation())
								+ StringUtils.CR + message);
			}

		}
	}

}