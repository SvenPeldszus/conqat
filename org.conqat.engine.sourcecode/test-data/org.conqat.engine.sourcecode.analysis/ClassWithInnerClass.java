/*--------------------------------------------------------------------------+
$Id: ClassWithInnerClass.java 28680 2010-06-23 16:18:40Z juergens $
|                                                                          |
| Copyright 2005-2010 Technische Universitaet Muenchen                     |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+--------------------------------------------------------------------------*/
package edu.tum.cs.conqat.dotnet.ila.xml;

import java.io.File;
import java.util.ArrayList;
import java.util.List;

import edu.tum.cs.commons.error.NeverThrownRuntimeException;
import edu.tum.cs.commons.string.StringUtils;
import edu.tum.cs.commons.xml.IXMLElementProcessor;
import edu.tum.cs.conqat.commons.node.ListNode;
import edu.tum.cs.conqat.commons.pattern.PatternList;
import edu.tum.cs.conqat.dotnet.ila.ILDependenciesImporterProcessor;
import edu.tum.cs.conqat.dotnet.ila.ILImporterProcessorBase;
import edu.tum.cs.conqat.dotnet.ila.Member;

/**
 * Reads members from Intermediate Language Analyzer XML files into a
 * representation that can be used for architecture assessments.
 * <p>
 * The currently implemented approach is very simplistic: (Change it as soon as
 * need arises!). All classes encountered in the IL-XML are read and appended as
 * children to a single root. Dependencies are stored in a key called
 * {@value ILDependenciesImporterProcessor#DEPENDENCIES}.
 * 
 * @author Elmar Juergens
 * @author $Author: juergens $
 * 
 * @version $Revision: 28680 $
 * @levd.rating YELLOW Hash: 495599931AE60A06E4FD6698FB2D9280
 */
public class IlaXmlReader extends IlaXmlReaderBase {

	/** Flag that determines whether to ignore types generated by the compiler */
	private final boolean ignoreSynthetic;

	/**
	 * If not null, types whose base class matches one of these patters are
	 * ignored
	 */
	private final PatternList ignoreBaseTypePatterns;

	/**
	 * Constructor
	 * 
	 * @param file
	 *            IL-XML file that gets parsed
	 * @param root
	 *            Root under which the nodes representing types found during
	 *            parse are attached
	 * @param ignorePatterns
	 *            List of patterns for members that are ignored during import.
	 * @param includePatterns
	 *            If not null, only members matching one of these patterns are
	 *            included.
	 * @param ignoreBaseTypePatterns
	 *            If not null, only types whose base types are not matched are
	 *            processed.
	 */
	public IlaXmlReader(File file, ListNode root, PatternList ignorePatterns,
			PatternList includePatterns, PatternList ignoreBaseTypePatterns,
			boolean ignoreSynthetic) {
		super(file, root, ignorePatterns, includePatterns);
		this.ignoreSynthetic = ignoreSynthetic;
		this.ignoreBaseTypePatterns = ignoreBaseTypePatterns;
	}

	/**
	 * Constructor that is used from test cases.
	 * 
	 * @param file
	 *            IL-XML file that gets parsed
	 * @param root
	 *            Root under which the nodes representing types found during
	 *            parse are attached
	 */
	/* package */IlaXmlReader(File file, ListNode root) {
		this(file, root, new PatternList(), null, null, true);
	}

	/** {@inheritDoc} */
	@Override
	protected void doParse() {
		root.setValue(ILImporterProcessorBase.ASSEMBLY_NAME,
				getStringAttribute(EIlaXmlAttribute.Name));
		processChildElements(new XmlTypeElementReader());
	}

	/** Processor for &lt;TypeElement&gt; nodes */
	private class XmlTypeElementReader implements
			IXMLElementProcessor<EIlaXmlElement, NeverThrownRuntimeException> {

		/** {@inheritDoc} */
		public void process() {
			if (skipType()) {
				return;
			}

			String typeName = getStringAttribute(EIlaXmlAttribute.Type);
			ListNode currentElementNode = new ListNode(typeName);
			root.addChild(currentElementNode);

			parseDeclType(currentElementNode);

			List<String> dependencies = parseDependencies(currentElementNode);
			logDependencies(dependencies, typeName);

			parseMembers(currentElementNode);

			parseToken(currentElementNode);
		}

		/** Read declaration type from XML into node */
		private void parseDeclType(ListNode currentElementNode) {
			parseAndStoreAttribute(EIlaXmlAttribute.DeclType,
					ILDependenciesImporterProcessor.DECLTYPE,
					currentElementNode);
		}

		/** Parse metadata token from XML into node */
		private void parseToken(ListNode currentElementNode) {
			parseAndStoreAttribute(EIlaXmlAttribute.Token,
					ILDependenciesImporterProcessor.TOKEN, currentElementNode);
		}

		/** Parse metadata token from XML into node */
		private void parseAndStoreAttribute(EIlaXmlAttribute attributeName,
				String targetKey, ListNode currentElementNode) {
			String value = getStringAttribute(attributeName);
			currentElementNode.setValue(targetKey, value);
		}

		/** Read dependencies from XML into node */
		private List<String> parseDependencies(ListNode currentElementNode) {
			List<String> dependencies = new ArrayList<String>();

			processDecendantElements(new DependsReader(dependencies,
					EIlaXmlElement.Extends));
			processDecendantElements(new DependsReader(dependencies,
					EIlaXmlElement.Implements));
			processDecendantElements(new DependsReader(dependencies,
					EIlaXmlElement.Depends));
			currentElementNode.setValue(ILImporterProcessorBase.DEPENDENCIES,
					dependencies);

			return dependencies;
		}

		/** Parse members from XMl into node */
		private void parseMembers(ListNode currentElementNode) {
			List<Member> members = new ArrayList<Member>();
			processDecendantElements(new MemberReader(members));
			currentElementNode.setValue(
					ILDependenciesImporterProcessor.MEMBERS, members);

			int ilStatementCount = 0;
			for (Member member : members) {
				ilStatementCount += member.getNumberIlStatements();
			}

			currentElementNode.setValue(
					ILDependenciesImporterProcessor.IL_STATEMENT_COUNT,
					ilStatementCount);
		}

		/** Determines whether a type should be skipped */
		private boolean skipType() {
			boolean isSynthetic = getBooleanAttribute(EIlaXmlAttribute.Synthetic);
			if (isSynthetic && ignoreSynthetic) {
				return true;
			}

			if (ignoreBaseTypePatterns == null) {
				return false;
			}

			// determine base type
			BaseTypeReader reader = new BaseTypeReader();
			processChildElements(reader);
			String baseType = reader.getBaseType();

			// match base type against ignore list
			boolean ignore = ignoreBaseTypePatterns.matchesAny(baseType);
			if (ignore) {
				String typeName = getStringAttribute(EIlaXmlAttribute.Type);
				System.err.println("Ingoring " + typeName + ": Base type: "
						+ baseType);
			}
			return ignore;
		}

		/** {@inheritDoc} */
		public EIlaXmlElement getTargetElement() {
			return EIlaXmlElement.TypeElement;
		}
	}

	/** Determines the base type of a type element */
	private class BaseTypeReader implements
			IXMLElementProcessor<EIlaXmlElement, NeverThrownRuntimeException> {

		/** Field to store base type */
		private String baseType;

		/** {@inheritDoc} */
		public EIlaXmlElement getTargetElement() {
			return EIlaXmlElement.Extends;
		}

		/** {@inheritDoc} */
		public void process() throws NeverThrownRuntimeException {
			baseType = getStringAttribute(EIlaXmlAttribute.Type);
		}

		/** Returns base type */
		public String getBaseType() {
			return baseType;
		}

	}

	/**
	 * Processor that processes dependencies. Target element is passed via the
	 * constructor, since it needs to operate on different target elements.
	 */
	private class DependsReader implements
			IXMLElementProcessor<EIlaXmlElement, NeverThrownRuntimeException> {
		/** Reference to list in which members are stored */
		private final List<String> dependencies;

		/** Target element this processor works on */
		private final EIlaXmlElement targetElement;

		/** Constructor */
		public DependsReader(List<String> dependencies,
				EIlaXmlElement targetElement) {
			this.dependencies = dependencies;
			this.targetElement = targetElement;
		}

		/** {@inheritDoc} */
		public EIlaXmlElement getTargetElement() {
			return targetElement;
		}

		/** {@inheritDoc} */
		public void process() {
			addDependency(getStringAttribute(EIlaXmlAttribute.Type),
					dependencies);
		}

	}

	/** Processor for &lt;Depends&gt; nodes */
	private class MemberReader implements
			IXMLElementProcessor<EIlaXmlElement, NeverThrownRuntimeException> {

		/** Reference to list in which members are stored */
		private final List<Member> members;

		/** Constructor */
		protected MemberReader(List<Member> members) {
			this.members = members;
		}

		/** {@inheritDoc} */
		public EIlaXmlElement getTargetElement() {
			return EIlaXmlElement.Member;
		}

		/** {@inheritDoc} */
		public void process() {
			String name = getStringAttribute(EIlaXmlAttribute.Name);
			String type = getStringAttribute(EIlaXmlAttribute.MemberType);
			String visibility = getStringAttribute(EIlaXmlAttribute.Visibility);
			boolean isAbstract = getBooleanAttribute(EIlaXmlAttribute.IsAbstract);
			String token = getStringAttribute(EIlaXmlAttribute.Token);
			String numberIlStatementsString = getStringAttribute(EIlaXmlAttribute.NumILStmts);
			int numberIlStatements = 0;
			if (!StringUtils.isEmpty(numberIlStatementsString)) {
				numberIlStatements = Integer.valueOf(numberIlStatementsString);
			}
			Member member = new Member(name, type, visibility, isAbstract,
					token, numberIlStatements);
			members.add(member);
		}
	}

}