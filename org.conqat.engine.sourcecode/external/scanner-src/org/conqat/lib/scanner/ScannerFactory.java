/*-------------------------------------------------------------------------+
|                                                                          |
| Copyright 2005-2011 The ConQAT Project                                   |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+-------------------------------------------------------------------------*/
package org.conqat.lib.scanner;

import java.io.File;
import java.io.FileReader;
import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;

import org.conqat.lib.scanner.ETokenType.ETokenClass;

/**
 * This factory class is the central access point to the scanner framework. It
 * offers different methods for constructing strict and lenient scanners for
 * different languages and different input formats.
 * <p>
 * Every scanner is associated with an origin id that is attached to every token
 * created by this scanner. It identifies the resource the tokens stem from.
 * However, the factory does not interpret the content of the originId but
 * merely passes it on to the scanners (and thus ultimately to the tokens). The
 * caller of the factory methods in this class thus needs to make sure that the
 * originIds are sane.
 * 
 * This factory can construct strict scanners (interface {@link IScanner}) and
 * lenient scanners (interface {@link ILenientScanner}). Strict scanners throw
 * {@link ScannerException}s if they encounter input they cannot recognize.
 * Lenient scanners do not throw {@link ScannerException}s, but instead return
 * tokens with a token type of token class {@link ETokenClass#ERROR}, specifying
 * the type of error encountered, and resume scanning.
 * 
 * @author $Author: hummelb $
 * @version $Revision: 51407 $
 * @ConQAT.Rating GREEN Hash: 8D4A15C2B4A6771B1203D2707AED22D4
 */
public class ScannerFactory {

	/**
	 * prevent instantiation
	 */
	private ScannerFactory() {
		// prevent instantiation
	}

	/**
	 * Create a new strict scanner for a file. Tokens generated by this scanner
	 * will carry the canonical path of the file as origin id.
	 * 
	 * @param language
	 *            implementation language
	 * @param file
	 *            the file to scan
	 * @return a new strict scanner
	 */
	public static IScanner newScanner(ELanguage language, File file)
			throws IOException {
		return strict(newLenientScanner(language, file));
	}

	/**
	 * Create a new lenient scanner for a file. Tokens generated by this scanner
	 * will carry the canonical path of the file as originId.
	 * 
	 * @param language
	 *            implementation language
	 * @param file
	 *            the file to scan
	 * @return a new lenient scanner
	 */
	public static ILenientScanner newLenientScanner(ELanguage language,
			File file) throws IOException {
		return newLenientScanner(language, new FileReader(file),
				file.getCanonicalPath());
	}

	/**
	 * Create a new strict scanner that scans a string.
	 * 
	 * @param language
	 *            implementation language
	 * @param input
	 *            the string to scan
	 * @param originId
	 *            origin id that denotes the resource the tokens stem from
	 * @return a new strict scanner
	 */
	public static IScanner newScanner(ELanguage language, String input,
			String originId) {
		return strict(newLenientScanner(language, input, originId));
	}

	/**
	 * Create a new lenient scanner that scans a string.
	 * 
	 * @param language
	 *            implementation language
	 * @param input
	 *            the string to scan
	 * @param originId
	 *            origin id that denotes the resource the tokens stem from
	 * @return a new lenient scanner
	 */
	public static ILenientScanner newLenientScanner(ELanguage language,
			String input, String originId) {
		return newLenientScanner(language, new StringReader(input), originId);
	}

	/**
	 * Create a new strict scanner that uses the specified reader.
	 * 
	 * @param language
	 *            implementation language
	 * @param reader
	 *            the reader to read the input from
	 * @param originId
	 *            origin id that denotes the resource the tokens stem from
	 * @return a new strict scanner
	 */
	public static IScanner newScanner(ELanguage language, Reader reader,
			String originId) {
		return strict(newLenientScanner(language, reader, originId));
	}

	/**
	 * Create a new lenient scanner that uses the specified reader.
	 * 
	 * @param language
	 *            implementation language
	 * @param reader
	 *            the reader to read the input from
	 * @param originId
	 *            origin id that denotes the resource the tokens stem from
	 * @return a new lenient scanner
	 */
	public static ILenientScanner newLenientScanner(ELanguage language,
			Reader reader, String originId) {
		switch (language) {
		case JAVA:
			return new JavaScanner(reader, originId);
		case CS:
			return new CSScanner(reader, originId);
		case CPP:
			return new CPPScanner(reader, originId);
		case VB:
			return new VBScanner(reader, originId);
		case PL1:
			return new PL1Scanner(reader, originId);
		case COBOL:
			return new CobolScanner(reader, originId);
		case ABAP:
			return new ABAPScanner(reader, originId);
		case ADA:
			return new AdaScanner(reader, originId);
		case TEXT:
			return new TextScanner(reader, originId);
		case XML:
			return new XMLScanner(reader, originId);
		case PLSQL:
			return new PLSQLScanner(reader, originId);
		case PYTHON:
			return new PythonScanner(reader, originId);
		case TSQL:
			return new TSQLScanner(reader, originId);
		case MATLAB:
			return new MatlabScanner(reader, originId);
		case PHP:
			return new PHPScanner(reader, originId);
		case RUBY:
			return new RubyScanner(reader, originId);
		case JAVASCRIPT:
			return new JavaScriptScanner(reader, originId);
		case MTEXT:
			return new MTextScanner(reader, originId);
		case LINE:
			return new LineScanner(reader, originId);
		case JPL:
			return new JPLScanner(reader, originId);
		case MAGIK:
			return new MagikScanner(reader, originId);
		case DELPHI:
			return new DelphiScanner(reader, originId);
		default:
			throw new IllegalArgumentException("Language '" + language
					+ "' not supported.");
		}
	}

	/**
	 * Wraps an {@link ILenientScanner} scanner with a {@link StrictScanner}.
	 */
	public static IScanner strict(ILenientScanner scanner) {
		return new StrictScanner(scanner);
	}
}