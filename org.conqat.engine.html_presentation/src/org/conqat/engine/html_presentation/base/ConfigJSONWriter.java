/*-------------------------------------------------------------------------+
|                                                                          |
| Copyright 2005-2011 the ConQAT Project                                   |
|                                                                          |
| Licensed under the Apache License, Version 2.0 (the "License");          |
| you may not use this file except in compliance with the License.         |
| You may obtain a copy of the License at                                  |
|                                                                          |
|    http://www.apache.org/licenses/LICENSE-2.0                            |
|                                                                          |
| Unless required by applicable law or agreed to in writing, software      |
| distributed under the License is distributed on an "AS IS" BASIS,        |
| WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. |
| See the License for the specific language governing permissions and      |
| limitations under the License.                                           |
+-------------------------------------------------------------------------*/
package org.conqat.engine.html_presentation.base;

import java.awt.Rectangle;
import java.io.File;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.IdentityHashMap;
import java.util.List;
import java.util.Map;

import org.conqat.engine.commons.util.JsonUtils;
import org.conqat.engine.core.conqatdoc.layout.BlockRendererBase.EChildType;
import org.conqat.engine.core.conqatdoc.layout.DesignConstants;
import org.conqat.engine.core.core.ConQATException;
import org.conqat.engine.core.core.IConQATProcessorInfo;
import org.conqat.engine.core.driver.info.BlockInfo;
import org.conqat.engine.core.driver.info.IInfo;
import org.conqat.engine.core.driver.info.InfoAttribute;
import org.conqat.engine.core.driver.info.InfoBase;
import org.conqat.engine.core.driver.info.InfoOutput;
import org.conqat.engine.core.driver.info.InfoParameter;
import org.conqat.engine.core.driver.info.InfoRefNode;
import org.conqat.engine.core.logging.ConQATLoggingEvent;
import org.conqat.engine.core.logging.LogManager;
import org.conqat.engine.html_presentation.javascript.config.ConfigJSModule;
import org.conqat.engine.html_presentation.javascript.config.StatisticsDataJson;
import org.conqat.lib.commons.collections.UnmodifiableList;
import org.conqat.lib.commons.color.ColorUtils;
import org.conqat.lib.commons.filesystem.FileSystemUtils;
import org.conqat.lib.commons.string.StringUtils;

/**
 * Code for writing out the configuration as JSON.
 * 
 * The files written are not actual JSON, since the valid JSON is wrapped inside
 * a function call that installs it in the DashboardPageBase class.
 * 
 * The following files are written:
 * <ul>
 * <li><b>statistics.json</b> contains overall statistical information that can
 * be aggregated into a "dashboard of dashboards".
 * <li><b>config.json</b> contains all relevant information about the executed
 * blocks and their processors, parameters and outputs.
 * <li><b>log.json</b> contains all log entries generated by the run config.
 * 
 * @author $Author: kinnen $
 * @version $Rev: 49983 $
 * @ConQAT.Rating GREEN Hash: 9E604CD61E8A55C21AACF7A611A15D63
 */
public class ConfigJSONWriter {

	/** Name of the execution statistics file. */
	public static final String STATISTICS_JSON = "statistics.json";

	/** Name of the log information file. */
	public static final String LOG_JSON = "log.json";

	/** Name of the config graph file. */
	public static final String CONFIG_JSON = "config.json";

	/** The log manager from which the log information is collected. */
	private final LogManager logManager;

	/** The root block for which information should be collected. */
	private final BlockInfo rootBlock;

	/** The file to which to write statistics information. */
	private final File statisticsFile;

	/** The file to which to write config information. */
	private final File configFile;

	/** The file to which to write log information. */
	private final File logFile;

	/** Maps unit names to internal ID. */
	private final Map<String, Integer> unitNameToId = new HashMap<String, Integer>();

	/** Maps elements to internal ID. */
	private final Map<Object, Integer> elementToId = new IdentityHashMap<Object, Integer>();

	/** Constructor. */
	public ConfigJSONWriter(IConQATProcessorInfo info, File outputDir)
			throws ConQATException {
		this.logManager = info.getLogManager();
		this.rootBlock = info.getConfigurationInformation();

		try {
			FileSystemUtils.ensureDirectoryExists(outputDir);
		} catch (IOException e) {
			throw new ConQATException("Could not create output directory "
					+ outputDir, e);
		}
		this.statisticsFile = new File(outputDir, STATISTICS_JSON);
		this.configFile = new File(outputDir, CONFIG_JSON);
		this.logFile = new File(outputDir, LOG_JSON);
	}

	/** Writes all the output files. */
	public void writeAll() throws ConQATException {
		try {
			buildProcessorNameMapping(rootBlock);
			writeStatistics();
			writeLog();
			writeConfig();
		} catch (IOException e) {
			throw new ConQATException("Error while writing config JSON files.",
					e);
		}
	}

	/**
	 * Recursively enumerates all processors, blocks, parameters and outputs and
	 * creates a mapping from their name to their ID.
	 */
	private void buildProcessorNameMapping(IInfo info) {
		unitNameToId.put(info.getInstanceName(), getId(info));
		if (info instanceof BlockInfo) {
			BlockInfo blockInfo = (BlockInfo) info;
			for (IInfo child : blockInfo.getChildren()) {
				buildProcessorNameMapping(child);
			}
		}
	}

	/** Writes the overall statistics of the {@link #rootBlock}. */
	private void writeStatistics() throws IOException {
		StatisticsDataJson data = new StatisticsDataJson(rootBlock, logManager.getLoggingEvents());
		FileSystemUtils.writeFileUTF8(statisticsFile,
				JsonUtils.serializeToJSON(data));
	}

	/** Creates the log JSON file. */
	private void writeLog() throws IOException {
		UnmodifiableList<ConQATLoggingEvent> events = logManager
				.getLoggingEvents();
		List<List<Object>> jsonData = new ArrayList<List<Object>>(events.size());
		for (ConQATLoggingEvent event : events) {
			Integer id = unitNameToId.get(event.getProcessorName());
			if (id == null) {
				// this happens when getProcessorName() above returns
				// "UNSPECIFIED"
				id = -1;
			}

			Object message = event.getMessage();
			String messageString = StringUtils.EMPTY_STRING;
			if (message != null) {
				messageString = message.toString();
			}

			jsonData.add(ConfigJSModule.createJsonLogEntry(id, event.getLevel()
					.name().toLowerCase(), messageString, event.getTime()));
		}

		FileSystemUtils.writeFileUTF8(logFile,
				ConfigJSModule.installLogJSON(jsonData));
	}

	/**
	 * Gathers information about the config and its connections and writes it to
	 * the {@link #configFile}.
	 * 
	 * @throws IOException
	 *             if writing to the JSON file fails.
	 */
	private void writeConfig() throws IOException {

		ConfigJSModule.ConfigGraphDataJson jsonData = new ConfigJSModule.ConfigGraphDataJson(
				getId(rootBlock));

		traverseConfig(rootBlock, new ConfigGraphRenderer(rootBlock),
				jsonData);
		FileSystemUtils.writeFileUTF8(configFile,
				ConfigJSModule.installConfigJSON(jsonData));
	}

	/**
	 * Recursively traverses the configuration graph and stores the extracted
	 * information in the builders.
	 * 
	 * @param info
	 *            The block that is currently being looked at
	 * @param parentRenderer
	 *            The renderer of the parent
	 * @param jsonData
	 *            The data object that holds all configuration information.
	 */
	private void traverseConfig(IInfo info,	ConfigGraphRenderer parentRenderer,
			ConfigJSModule.ConfigGraphDataJson jsonData) {
		int id = dumpElementDetails(info, parentRenderer, jsonData);
		if (!(info instanceof BlockInfo)) {
			return;
		}

		BlockInfo blockInfo = (BlockInfo) info;
		ConfigJSModule.BlockDataJson blockData = new ConfigJSModule.BlockDataJson(
				blockInfo);
		jsonData.addBlock(id, blockData);
		ConfigGraphRenderer renderer = new ConfigGraphRenderer(blockInfo);
		traverseBlockChildren(jsonData, blockInfo, blockData, renderer);
		traverseBlockConnections(blockInfo, blockData, renderer);

		for (IInfo child : blockInfo.getChildren()) {
			traverseConfig(child, renderer, jsonData);
		}
	}

	/**
	 * Assemble connection information by looking backwards from all attributes
	 * and outputs.
	 */
	private void traverseBlockConnections(BlockInfo blockInfo,
			ConfigJSModule.BlockDataJson blockData, ConfigGraphRenderer renderer) {
		for (IInfo child : blockInfo.getChildren()) {
			for (InfoParameter targetParameter : child.getParameters()) {
				for (InfoAttribute targetAttribute : targetParameter
						.getAttributes()) {
					createConnection(blockData, renderer, targetAttribute
									.getReferenced(), child);
				}
			}
		}

		for (InfoOutput output : blockInfo.getOutputs()) {
			InfoRefNode referenced = output.getReferenced();
			createConnection(blockData, renderer, referenced, output);
		}
	}

	/**
	 * Creates a new connection in the given block data between the given referenced node
	 * and target. The connection's visibility is determined using the given renderer.
	 */
	private void createConnection(ConfigJSModule.BlockDataJson blockData,
			ConfigGraphRenderer renderer, InfoRefNode referenced, Object target) {
		Object referencedInfo = infoRefNodeToInfo(referenced);
		boolean invisible = renderer
				.getSourceEdgesInvisible(referencedInfo);
		blockData.connect(getId(referencedInfo), getId(target),
				invisible);
	}

	/** Assemble information about the children of the given block. */
	private void traverseBlockChildren(
			ConfigJSModule.ConfigGraphDataJson jsonData, BlockInfo blockInfo,
			ConfigJSModule.BlockDataJson blockData, ConfigGraphRenderer renderer) {
		for (IInfo child : blockInfo.getChildren()) {
			blockData.addMember(getId(child));
		}
		for (InfoOutput output : blockInfo.getOutputs()) {
			dumpElementDetails(output, renderer, jsonData);
			blockData.addMember(getId(output));
		}
		for (InfoParameter param : blockInfo.getParameters()) {
			// dumping the details is necessary for all parameters, since
			// synthetic ones also show up in the parameters table
			dumpElementDetails(param, renderer, jsonData);
			if (!param.isSynthetic()) {
				blockData.addMember(getId(param));
			}
		}
	}

	/**
	 * Returns the {@link IInfo} of the object referenced by the
	 * {@link InfoRefNode}.
	 */
	private Object infoRefNodeToInfo(InfoRefNode node) {
		if (node instanceof InfoAttribute) {
			return ((InfoAttribute) node).getParameter();
		}
		if (node instanceof InfoOutput) {
			return ((InfoOutput) node).getInfo();
		}

		return null;
	}

	/**
	 * Returns the ID of the given object. Creates a new id if there is none
	 * yet.
	 */
	private int getId(Object element) {
		Integer id = elementToId.get(element);
		if (id == null) {
			id = elementToId.size();
			elementToId.put(element, id);
		}
		return id;
	}

	/**
	 * Extracts information about the given element and stores it in the JSON
	 * object.
	 */
	private int dumpElementDetails(Object element,
			ConfigGraphRenderer parentRenderer,
			ConfigJSModule.ConfigGraphDataJson jsonData) {
		int id = getId(element);
		String name = parentRenderer.getName(element);
		EChildType type = parentRenderer.getType(element);
		String typeName = parentRenderer.getTypeName(element);
		String color = ColorUtils.toHtmlString(parentRenderer
				.getBackgroundColor(element));

		Rectangle bounds = parentRenderer.getBounds(element);
		if (type == EChildType.BLOCK || type == EChildType.PROCESSOR) {
			bounds.grow(-DesignConstants.PORT_INSET,
					-DesignConstants.PORT_INSET);
		}

		jsonData.addElement(id, type.name(), name, typeName, color, bounds.x,
				bounds.y, bounds.width, bounds.height);

		if (element instanceof InfoBase) {
			jsonData.addParameters(id, (InfoBase) element);
		}
		return id;
	}

}
